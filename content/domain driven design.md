---
title: "Domain Driven Design"
metaTitle: "DDD"
metaDescription: "DDD"
---
The term DDD was first coined by Eric Evans in his book  "Domain Driven Design: tackling complexity in the heart of software" published in 2003. At that time the core was about designing models to create software. Since then the community that established around DDD took it further which makes DDD today greater then just finding a useful model for the domain based on the language.

Domain driven design is a centered set. It has no boundary. The question that determines if you are part of the set or not is simply, "Do you care about what I care about?"

- **bounded set**: everything in the set makes it the thing, everything out the set makes it not the thing

- **centered set**: There is no dividing line between us and them no rules or guidelines to determine who is “in” and who is out. Everyone is loved, welcomed, and accepted, no matter what. But offcourse there is something that pulls the herd to the center. An example is a waterhole in the savanne, there you can find several animals drinking from the same water that actually eat eachother.

![alt text](./static/boundedvscenteredset.png "DDD is a centered set")

If DDD is a centered set the following items belong to this set:

![alt text](./static/DDD-centered-set.png "sample of items that belong to DDD centered set")

A lot of DDD principles are common sense or what Simon Wardley calls doctrine in wardley mapping. 

- doctrine: things that are universally good ideas

![alt text](./static/doctrine.jpeg "wardley mapping")

The problem with common sense is companies think it is common sense to maken one big universal model for the whole company. DDD just says you need multiple models for smaller contexts.

The way Mathias Verraes explains DDD to new people

![alt text](./static/DDD-mathias.png "Mathias' DDD definition")

* Design discipline (the more you do it the more benefits you get)

#DDD qualifiers

**Collaborative modeling**

- eventstorming (big picture, process modeling, design level)
- responsability mapping (old and not popular)
- domain story telling

- DDD (strategic, tactical)



# bounded context 

"understandability boundaries" I am able to understand this stuff with this model and this language, allowing me to be productive without the need to understand the rest of the system

Programming is modeling in itself. Computers need very precise models because computers are very strict. DDD is a way to business understand itself, it forces us to understand it.

ubiquituous language in a context. 


Collaborative modeling


